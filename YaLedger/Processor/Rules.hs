{-# LANGUAGE GADTs, RecordWildCards, FlexibleContexts #-}
module YaLedger.Processor.Rules
  (runRules) where

import Control.Monad.State
import Control.Monad.Exception
import Control.Monad.Loc
import Data.Maybe
import Data.Decimal
import qualified Data.Map as M
import Data.Dates

import YaLedger.Types
import YaLedger.Monad
import YaLedger.Exceptions
import YaLedger.Kernel
import YaLedger.Kernel.Correspondence
import YaLedger.Processor.Templates

-- | Check if posting matches to 'Condition'
matchC :: Throws NoSuchRate l
       => DateTime            -- ^ Posting date/time
       -> Posting Decimal t   -- ^ Posting itself
       -> Condition
       -> Ledger l Bool
matchC date (CPosting acc x) cond = check ECredit date acc x cond
matchC date (DPosting acc x) cond = check EDebit  date acc x cond

check t date acc x (Condition {..}) = do
  coa <- gets lsCoA
  let accID = getID acc
  let grps = fromMaybe [] $ groupIDs accID coa
      action = maybe [ECredit, EDebit] (\x -> [x]) cAction
  if (t `elem` action) &&
     ((accID `elem` cAccounts) ||
      (any (`elem` cGroups) grps))
    then do
         let accountCurrency = getCurrency acc
         if cValue == AnyValue
           then return True
           else do
                let (op, v) = case cValue of
                                MoreThan s -> ((>), s)
                                LessThan s -> ((<), s)
                                Equals s   -> ((==), s)
                                _ -> error "Processor.Rules.matchC.check: Impossible."
                condValue :# _ <- convert (Just date) accountCurrency v
                return $ x `op` condValue
    else return False

-- | Apply given function to all transactions which are
-- produced by all rules, applicable for this posting
runRules :: (Throws NoSuchRate l,
             Throws NoCorrespondingAccountFound l,
             Throws InvalidAccountType l,
             Throws NoSuchTemplate l,
             Throws InternalError l)
         => DateTime                                   -- ^ Date/time of the posting
         -> Attributes                                 -- ^ Posting attributes
         -> Posting Decimal t                          -- ^ Posting itself
         -> (Ext (Transaction Amount) -> Ledger l ())  -- ^ Function to apply to produced transactions
         -> Ledger l ()
runRules date pAttrs p run = do
  rules <- gets lsRules
  forM_ rules $ \(name, attrs, When cond tran) -> do
    y <- matchC date p cond
    if y && (pAttrs `matchAll` cAttributes cond)
      then do
           let attrs' = M.insert "rule" (Exactly name) (pAttrs `M.union` attrs)
               (c, x) = case p of
                            DPosting acc x -> (getCurrency acc, x)
                            CPosting acc x -> (getCurrency acc, x)
           tran' <- fillTemplate tran [x :# c]
           let pos = newPos ("<generated by rule \"" ++ name ++ "\">") 0 0
           run (Ext date pos attrs' tran')
      else return ()

